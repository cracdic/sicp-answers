#lang racket
(require racket/include)
(include "3.5.1.rkt")

;具体的生成过程推理是很费劲的，但是根据运行的结果可以看作是是递归的生成了很多序列

;S = A[(1,1)] + B[(1,2)(1,3)(1,4)...] + C
;C = Ca[(2,2)] + Cb[(2,3)(2,4)(2,5)...] + Cc
;Cc = Da[(3,3)] + Db[(3,4)(3,5)(3,6)(3,7)...] + Dc
;...

;S从B，C之中交替取出序对
;C从Cb，Cc中交替取出序对
;Cc从Db, Dc中交替取出序对
;...

;前十五个结果(1,1)(1,2)(2,2)(1,3)(2,3)(1,4)(3,3)(1,5)(2,4)(1,6)(3,4)(1,7)
;(2,5)(1,8)(4,4)...

;对(1,n)和(n,n)找规律......

;(n,n)是第2**n-1个序对，之前有2**n-2个
;(1,n)是第2*n-2个序对((1,1)除外)，之前有2*n-3个

(define 2-integer (pairs integers integers))

(stream-head 2-integer 15)